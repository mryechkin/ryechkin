---
title: 'MUX: Rethinking CSS styling for v4'
date: '2022-01-10'
summary: ''
canonical: 'https://misha.wtf/blog/css-in-js'
tags: ['CSS-in-JS', 'Styling', 'Exploration']
seo:
  [
    'CSS-in-JS',
    'Styled System',
    'System-UI',
    'styling',
    'design system',
    'component library',
  ]
author:
  name: 'Mykhaylo Ryechkin'
  url: 'https://twitter.com/mryechkin'
---

## Background

When MUX was originally created, we took a fairly restrictive stance on styling and customization of components. The idea was to ensure alignment with the specs in the Canadian Design System, with minimal deviations from the established designs. This was accomplished via the `customStyle` prop, with a [limited set](https://mux.manulife.com/?path=/docs/customization-styling-customstyle--page) of allowed CSS properties that can be overridden.

However, as more projects started to use MUX, it became evident that many didn't align 100% with the design system, and as such more flexibility was required. Additionally, with teams outside of Canada starting to use MUX, we also needed to enable support for the [Connected Design System](https://design.manulife.com/). This led to introduction of [themes](https://mux.manulife.com/?path=/docs/customization-theming-overview--page) in `v2`, and eventually some more CSS properties were added to the white-list.

Today, we know that this approach is still not good, which is echoed by the numerous feedback we've received over the last 6+ months. We want to fix this in the next major release, and create a solid foundation for the library moving forward.

## Feedback

Below is some of the feedback we've received on this:

![Screen Shot 2021-11-30 at 2 50 20 PM](https://user-images.githubusercontent.com/5657181/144126854-67a33fb9-4b53-4704-9b6d-ecf5f95397b6.png)

![Screen Shot 2021-11-30 at 2 52 27 PM](https://user-images.githubusercontent.com/5657181/144126911-4d8e8685-1e20-47f4-bd51-cbf081e6a62f.png)

![Screen Shot 2021-11-30 at 2 52 45 PM](https://user-images.githubusercontent.com/5657181/144126994-b7c0c67c-f642-45a1-a6d4-38f8d4791c48.png)

![Screen Shot 2021-11-30 at 2 53 28 PM](https://user-images.githubusercontent.com/5657181/144127058-e67e1873-2a7c-4ff9-8d14-7b8cf47c6d54.png)

![Screen Shot 2021-11-30 at 3 28 06 PM](https://user-images.githubusercontent.com/5657181/144127085-22cd494a-a847-4ebb-a824-80561302aacd.png)

![Screen Shot 2021-11-30 at 3 28 18 PM](https://user-images.githubusercontent.com/5657181/144127107-621c127a-2904-4bfb-a2dd-0e487d046b09.png)

![Screen Shot 2021-11-30 at 3 28 33 PM](https://user-images.githubusercontent.com/5657181/144127126-5bda4972-d9ee-40ee-9f9c-06f4542505f8.png)

![Screen Shot 2021-11-30 at 3 28 46 PM](https://user-images.githubusercontent.com/5657181/144127192-a05353bc-8ba7-4a62-bc8c-a4d86286cc76.png)

![Screen Shot 2021-11-30 at 3 29 01 PM](https://user-images.githubusercontent.com/5657181/144127286-eb062b9e-2ad0-46f3-a6d4-1694bb3a5544.png)

![Screen Shot 2021-11-30 at 3 29 09 PM](https://user-images.githubusercontent.com/5657181/144127299-9d8f2ea0-8efd-4f58-a489-de20369b3c37.png)

## Next Steps

With the above feedback in mind, we need to rethink how we approach styling and customization of components in MUX going forward, and what needs to be done to address this in `v4`.

## Considerations

Whatever approach we decide on, it needs to satisfy the following criteria:

- Supports server-side rendering (SSR)
- Supports theming and design tokens (such as [colors](https://design.manulife.com/5a19a5bd7/p/225f6b-colours/b/760c23), [spacing](https://design.manulife.com/5a19a5bd7/p/878bee-spacing/b/514c58) and [typography](https://design.manulife.com/5a19a5bd7/p/17960d-typography/b/14232))
- Flexible
- Familiar to users (ie. using established syntax / patterns rather than creating a bespoke solution)
- Performant

## Reference Material

Below is some reference material that's worth checking out. Please read these, as it will help us make better informed decisions, and perhaps utilize patterns / tech that other projects have successfully adopted.

- [Discussion on replacing SASS](https://github.com/Shopify/foundational-design-system-proto/discussions/44) in Shopify's [Foundational Design System](https://github.com/Shopify/foundational-design-system-proto) (successor to [Polaris](https://polaris.shopify.com/)) ðŸ‘ˆ great summary and comparison of the current CSS tech (**MUST READ**)
- [System-UI Theme Spec](https://system-ui.com/theme/) - theming spec that's followed by many design systems / component libraries
- The `sx` prop: common pattern for inline style overrides using theme-aware properties (used by [Theme-UI](https://theme-ui.com/sx-prop), [Material-UI](https://mui.com/system/basics/#the-sx-prop) and [Chakra-UI](https://chakra-ui.com/docs/features/the-sx-prop) to name a few)

## Comments:

I've been looking ito this for some time now, and believe I have a solution that will work well alongisde our established patterns, and be able to address most, if not all, of the above-mentioned issues.

In doing this research, I've come across and tried out a number of styling solutions that exist today - some of them fairly new to the scene, others with a well-established history. My process was to first try them out on their own, to see what kind of developer experience (DX) they provide - both from a consumption, and authoring perspectives. After all, if a given solution offers a worse experience than what we have, that's not something we'd want to force onto our users, maintainers and contributors.

As a baseline, I used our current setup in MUX: `styled-components` using tagged template literals for style definitions, with styles defined in a specific separate file for each component. It was important that using the given solution would provide at least a comparable experience. My goal was to avoid anything that would involve significant refactoring.

Then, if I was happy with a given solution, I would see how well it would integrate into MUX. This would include the component code itself, as well as tests and Storybook. It's important that stuff still worked and we could maintain our established level of code quality.

Based on the above criteria, I tested the following styling systems:

- [`Theme-UI`](https://theme-ui.com/) + [`Emotion`](https://emotion.sh/)
- [`Styled System`](https://styled-system.com/) + [`styled-components`](https://styled-components.com/)
- [`Stitches`](https://www.stitches.dev/)
- [`vanilla-extract`](https://vanilla-extract.style/) (logical successor to [`CSS Modules`](https://github.com/css-modules/css-modules))

When it comes to DX, all of the above libraries delivered a great experience and intuitive API's, with many shared principles. Going with any of the options would provide a great authoring experience, as well as an intutive API for the users. The familiar `styled` API is present in all of them.

Testing, however, was another story. I had run into issues with getting tests to work with several of these libraries when integrating into our existing setup. For instance, I had trouble getting `Emotion` to work properly in our test environment, which unfortunately eliminated `Theme-UI` from the list. And in `Stitches`, the `toHaveStyleRule()` type of matcher for Jest doesn't exist, so the only option to test components would be with snapshots, which isn't ideal.

When it comes to integrating into MUX, the only library I struggled to wire into our stack was `vanilla-extract`. It uses static CSS extraction at its core (as it's a successor to `CSS Modules` and is being developed by the same author), and works via a plugin for various modern build systems. Well, almost all. It unfortunately doesn't have a plugin for [`Rollup`](https://www.rollupjs.org/), which is what we use to package MUX. They instead provide a plugin for [`Vite`](https://vitejs.dev/), which utilizes `Rollup` under the hood, but cannot be used as a standalone plugin. So unless we switch our build system, this makes it an unviable option.

Ultimately, I had landed on a solution that I believe will work well for us: `Styled System` + `styled-components`. This option provides us with an intuitive style customization API (either via the [`css` prop](https://styled-components.com/docs/api#css-prop), or extending a component using `styled` API), and it integrates smoothly into our existing solution (as it works with `styled-components`). This means that we can continue utilizing most of our existing tests and there would be minimal refactoring required to provide this functionality.

For theming, `Styled System` adheres to the [`System UI Theme Spec`](https://system-ui.com/). This is a theme format that has been adopted by a number of popular component libraries, and lends itself well to working with [Design Tokens](https://spectrum.adobe.com/page/design-tokens/), which is also something that we'd like to start utlizing in MUX. It enforces a consistent naming convention for configuring and using common token values (such as colours, spacing, typography, etc.), as well as supporting things like Dark Mode (another feature that we'll need to support eventually). Check out [this blog post](https://jxnblk.com/blog/interoperability/) by its author that speaks more to this interoperability and where it originated from.

Here's an example of what this theme spec would look like within our existing theme files, utilizing design tokens from the Global [Connected Design System](https://design.manulife.com/5a19a5bd7/p/878bee-spacing/t/85cbac)

```jsx
const canadianTheme = {
  name: 'canadianTheme',
  breakpoints: ['320px', '768px', '1024px', '1280px', '1920px'],
  colors: {
    ...brandingColors,
    text: brandingColors.dark_navy,
    primary: brandingColors.coral,
    secondary: brandingColors.light_1_coral,
    modes: {
      dark: {
        text: brandingColors.light_3_grey,
        primary: brandingColors.light_1_coral,
        secondary: brandingColors.dark_1_coral,
      },
    },
  },
  sizes: {
    'layout-0': 0,
    'layout-1': '0.5rem',
    'layout-2': '1rem',
    'layout-3': '1.5rem',
    'layout-4': '2rem',
    'layout-5': '2.5rem',
    'layout-6': '3rem',
    'layout-7': '4rem',
    'layout-8': '6rem',
    'layout-9': '10rem',
    full: '100%',
  },
  space: {
    'spacing-0': 0,
    'spacing-1': 4,
    'spacing-2': 8,
    'spacing-3': 12,
    'spacing-4': 16,
    'spacing-5': 24,
    'spacing-6': 32,
    'spacing-7': 40,
    'spacing-8': 48,
    'spacing-9': 64,
  },
  fonts: {
    sans: '"Manulife JH Sans", "Helvetica", "Arial", system-ui, sans-serif',
    serif: '"Manulife JH Serif", serif',
  },
  fontSizes: {
    '2xs': 13,
    xs: 14,
    sm: 15,
    base: 16,
    lg: 17,
    xl: 18,
    '2xl': 22,
    '3xl': 23,
    '4xl': 24,
    '5xl': 25,
    '6xl': 26,
    '7xl': 30,
    '8xl': 32,
    '9xl': 34,
    '10xl': 36,
    '11xl': 38,
    '12xl': 42,
    '13xl': 47,
    '14xl': 48,
    '15xl': 56,
    '16xl': 60,
  },
  fontWeights: {
    light: 300,
    normal: 400,
    demiBold: 600,
    bold: 700,
    body: 'normal',
    heading: 'bold',
  },
  lineHeights: {
    xs: 16,
    sm: 20,
    base: 24,
    lg: 28,
    xl: 32,
    '2xl': 36,
    '3xl': 40,
    '4xl': 44,
    '5xl': 48,
    '6xl': 52,
    '7xl': 56,
    '8xl': 60,
    '9xl': 64,
    '10xl': 68,
    '11xl': 72,
    '12xl': 84,
  },
  radii: {
    none: '0',
    sm: '0.125rem',
    base: '0.25rem',
    md: '0.375rem',
    lg: '0.5rem',
    xl: '0.75rem',
    '2xl': '1rem',
    '3xl': '1.5rem',
    full: '9999px',
  },
  // ... rest of existing theme config
};
```

So what exactly does this all enable us to do? Well, let's look at a hypothetical scenario. Let's say a project already utilizes MUX, but needs to do some customizations to support co-branding. For example, the `Button` component needs to have a different (custom) background colour, font, padding, and rounded edges. Today, there's no simple way of doing that in MUX without having to jump through a bunch of hoops, and in some cases it may outright not be possible. Even if we got rid of the [whitelist of CSS properties](https://mux.manulife.com/?path=/docs/customization-styling-customstyle--page), specifying the necessary overrides via `customStyle` prop gets pretty ugly. Add to that any responsive styles, and it gets even messier.

With the proposed solution, doing something like that becomes non-trivial. We can include any necessary customizations in the theme file, and then utilize those values in our `Button` component by specifying the overrides via the `css` prop.

To start, you can add / override additional values in the theme file:

```jsx
// theme.js
{
  colors: {
    // ...
    'cobrand-primary': '#4f46e5',
    'cobrand-secondary': '#6366f1',
  },
  fonts: {
    // ...
    cobrand: 'Comic Sans MS, Textile, Cursive', // don't judge :P
  }
}
```

Now that they're in the theme, Styled System can access these values and use them in the CSS properties we decide to customize.

So for our example above, to get the desired effect we can specify these CSS overrides via the `css` prop, using our cobranding values:

```jsx
<Button
  css={{
    backgroundColor: 'cobrand-primary',
    borderColor: 'cobrand-primary',
    borderRadius: 'full',
    fontFamily: 'cobrand',
    '&:hover': {
      backgroundColor: 'cobrand-secondary',
      borderColor: 'cobrand-secondary',
    },
  }}
>
  Click Me
</Button>
```

Now imagine you also wanted to add responsive styles, and include different style overrides depending on screen size. You can do this by using Styled System's [Array Props](https://styled-system.com/guides/array-props) syntax, and specify different values for different breakpoints in a particular property.

Let's say we'd like to adjust the padding for mobile, tablet and desktop separately. To do this, simply write the value as an array, with the first array value mapping to everything below the `320px` breakpoint, then `768px`, `1024px` and so on (these map to the `breakpoints` key in the theme):

```jsx
<Button
  css={{
    // ...
    padding: ['spacing-1', 'spacing-2', 'spacing-3'],
  }}
>
```

The `padding` (or `p` for short) style property maps to the `space` key in the theme, and as such we can use the values defined there. The values `'spacing-1', 'spacing-2', 'spacing-3'` are interpreted by Styled System as `'4px', '8px', '12px'`. Note that it interprets numbers as pixel values, if no other unit value is specified. If you wanted `rem`'s, for example, then you'd need to define the values in the theme as `'spacing-1': '4rem'` etc.

To see all the available mappings, see complete [reference table](https://styled-system.com/table) for more details.

Best part of the above? Enabling something like that takes only a few lines of code.

We would be utilizing only the [`@styled-system/CSS`](https://styled-system.com/css) package, rather than the entire Styled System library, to keep things simple. All we'd need is:

1. Import it:

```jsx
import css from '@styled-system/css';
```

2. Then, have our `Button` component accept a prop called `css`:

```jsx
const Button = forwardRef(
  (
    {
      // ...
      css: _css,
    }
  )
```

3. And finally use `css` from Styled System to enhance the `css` prop to pass to our existing `styled-components`:

```jsx
<ButtonWrapper
  // ...
  css={css(_css)}
>
```

And that's it! The rest is handled by the magic of `styled-components`, and the [Babel plugin](https://styled-components.com/docs/tooling#babel-plugin) they provide, which enables the use of [`css` prop](https://styled-components.com/docs/api#css-prop).

Note that you can also use this together with the `styled` API from `styled-components` as well, if preferred:

```jsx
import { Button } from '@manulife/mux';
import styled from 'styled-components';
// ...
const CustomButton = styled(Button)(
  css({ ... }),
);
```

Either syntax accomplishes the same result.

What I personally like is the fact that this is the least intrusive, yet beneficial, approach to custom styling, given our existing tech stack and establishd patterns. It would cause the least disruption, while giving us greater improved capabilities for custom styling.
