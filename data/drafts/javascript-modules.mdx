---
title: 'JavaScript Module Ecosystem'
date: '2021-12-01'
summary: 'Overview of the JavaScript module ecosystem.'
canonical: 'https://misha.wtf/blog/javascript-modules'
tags: ['JavaScript', 'ESM', 'CommonJS']
seo: ['JavaScript', 'Modules', 'Node.js', 'CommonJS', 'CJS', 'ESM']
author:
  name: 'Mykhaylo Ryechkin'
  url: 'https://twitter.com/misha_wtf'
---

## Intro

In this post, we will take a look at one of the most fundamentals areas of JavaScript - its module system. We work with JavaScript modules on the daily basis, and it's important to understand their behaviour so that we don't get caught off-guard with some of the specifics.

## Brief History

Before we dive into what modules are, let's take brief look at some JavaScript history.

For most of its life, the web had only one way to load script files - via plain `<script>` tags:

```jsx
<script src="hi.js"></script>
<script src="hello.js"></script>
```

This is now what we refer to as **classic** scripts. In classic scripts, all scope is shared (ie. global). There is also no explicit way to specify dependency between files, so order of `<script>` tags very much matters. As you can guess, things get really messy, really quickly!

Over time, various tools started to emerge to help solve some of those limitations. Nowadays, JavaScript bundlers like [Webpack](https://webpack.js.org/), [Rollup](https://www.rollupjs.org/), [Parcel](https://parceljs.org/) or [esbuild](https://esbuild.github.io/) are pretty much a standard in most modern JavaScript tech stacks. These bundlers generate the final application (or library) bundle, and allow us to use JavaScript modules.

Why do we even need code bundling, you may ask? In high-latency environments (like the browser), it's faster to send one large file, rather than many small ones. But more importantly, bundling enables us to utilize JavaScript modules in our code.

## So what are modules anyway?

Modules are essentially a way to organize code in JavaScript. They let us write code in one file that explicitly depends on (or is a dependency of) code in another file.

When browsers / Node load modules, they build a map of all the modules that are used in the project. This process is called **module resolution**, and the map of modules is often referred to as a **module graph**.

## Module Specifiers

Modules are loaded using keywords like `import` and `require`:

```js
import { something } from './module.js';
```

```js
const something = require('./module');
```

These are called **module specifiers**. Some differences exist, depending on the module format. We'll get to this soon.

Module specifiers can be either full or relative URL's:

```js
import { other } from 'https://some.cdn.com/some/module.js';
```

```js
import { something } from './module.js';
```

They can also be "bare" (ie. without specifying file extensions):

```js
import { something } from 'module';
```

**NOTE:** this bare specifier is not supported natively in browsers yet

## Module Scope

The way modules are loaded is different between browsers and server environments (ie. Node).

Browsers load modules as **stateful singletons** - meaning that the same module will share its state anywhere it's imported in the application for that session.

In a Node environment, however, modules are loaded as **instances** - and as such, each instance has its own state, not shared with any of the other instances of the same module.

## Module Formats

There are several different module formats:

- **ES Modules** (or **ESM**)
- **CommonJS** (or **CJS**)
- **AMD**
- **UMD**
- **System**

Why so many?

First, there are different JavaScript runtime environments. We have the **browser** with its various implementations (Chrome, Firefox, Safari, etc), and then we have the **server**, with runtimes like [Node](https://nodejs.org/) and [Deno](https://deno.land/t).

For a long time, there wasn't a single, agreed-upon standard between those environments in terms of how to deal with modules. There were concurrent attempts at solving the problem (even JS standards are _async_, how meta!) - and as a result, the module formats abov have emerged.

Eventually, module format was standardized by the [TC39](https://tc39.es/) committee, with **ES Modules** (or **ESM**) becoming the standard going forward. It, along with the other popular format **CommonJS** (or **CJS**), are the two formats you are most likely to come across and work with today.

Let's take a bit more in-depth look at both.

### ES Modules (ESM)

**ESM** is the standard established and governed by the [TC39](https://tc39.es/) committee. It is the modern standard for JavaScript modules going forward, and is supported natively by all major browsers, as well as newer versions of Node (15+). For Node 14 and below, ESM can be enabled with the help of 3rd party libraries (more on that later).

ESM uses `.js` and `.mjs` extensions (browser and Node, respectively), and utilizes `import` keyword for importing, and `export` for exporting. It also exposes either "default" or "named" exports:

```js
// foo.js
const foo = 'foo';

// named export
export const bar = 'baz';

// default export
export default foo;

// index.js
import foo, { bar } from './foo.js';

console.log(foo); // "foo";
console.log(bar); // "baz";
```

To import **named** exports, put them inside the curly braces (ie. `{ bar }`), whereas default imports go outside the curly braces.

Due to the nature of ES Modules, code written in it can be statically analyzed and "tree-shaken", so that no extra unused JavaScript is included in the bundle.

Some other characteristics and rules of ESM:

- `import`'s are static and async (browsers are async in their nature, after all)
- `import`'s must live at the root level
- `import` specifier can only accept a string literal (ie. it can't be dynamically generated)
- `import`'s also get hoisted, so can be written anywhere in the code

To load an ES Module in a browser, we need to specify `type` as `"module"` in the script tag:

```jsx
<script type="module" src="/some-module.js"></script>
```

When loading in Node, there are several ways to ensure ESM is used:

- Set `type` field to `"module"` in the `package.json` of the project
- Using the `.mjs` file extension
- Using `--input-type=module` flag via Node CLI

### CommonJS (CJS)

**CJS** is a module system that originated in [Node](https://nodejs.org/). It uses `module.exports` keyword for exporting, and the `require` keyword for importing:

```js
// foo.js
module.exports = {
  bar: 'baz';
};

// index.js
const foo = require('./foo.js');
console.log(foo.bar); // "baz"
```

CommonJS uses `.js` and `.cjs` file extensions, and it **cannot** be loaded directly in a browser. For that exist specific tools (such as [Browserify](https://browserify.org/)) that allow us to run CommonJS code in a browser environment.

CJS modules are loaded dynamically, at runtime. They use the `require` keyword, which can accept JavaScript expressions (ie. it's dynamic). However, because of that, JavaScript tools can't know what's going to be loaded ahead of time. This makes CJS modules **not tree-shakeable**, often resulting in bigger bundles.

Some other characteristics of CJS to be aware of:

- Module specifier is a function call (`require(...)`) and is synchronous (ie. blocking)
- Module resolution is synchronous
- Exposes object `module.exports`

## Interoperability

With all the differences between the module formats we've seen so far (we've only covered 2), and the different environments they can be used in, it's evident why there is such a strong need for a **single** uniform module specification.

Now let us ask a question: **"What happens if you want to use a CJS module inside an ESM one? Or the other way around?"**

And the answer is - natively, you can't. Bundlers and transpilers such as **Babel**, **Webpack**, **Rollup** etc. have been doing a decent job of ensuring compatibility between the different formats and runtimes, however some [edge cases](https://github.com/rollup/plugins/issues/481) and [issues](https://github.com/babel/babel/issues/12363) still exist today.

You might also be wondering: **"Why is it difficult to move away from CommonJS?"**

First, it's _everywhere_. It's still the main format used in Node, and has been for years (Node only recently started supporting ESM).

Second, it's a lengthy process. Lots of large (and popular) codebases and tools still use and heavily rely on it. So while there may be a single unified format down the road (ESM), it is not an overnight change, and will take some time for the entire ecosystem to migrate to it.

There are some folks who are eager to help [move the ecosystem forward](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c), though others are [against the idea](https://gist.github.com/joepie91/bca2fda868c1e8b2c2caf76af7dfcad3) altogether. Both sides present valuable arguments, and the discussions are worth checking out.

## Tree Shaking

**"Tree-shaking"** or what is also known as **"dead code elimination"** is a process through which tools such as **Webpack** and **Rollup** do static analysis of your code, and try to determine which modules aren't utilized. Doing this allows us to drastically cut down on the overall bundle size, and only include what's actually needed to run the app / library.

ESM is much more compatible with this process. How you structure your exports also plays a big role in whether a module can be tree-shaken or not.

## Reference Material:

- https://github.com/sindresorhus/meta/discussions/15
- https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c
- https://gist.github.com/joepie91/bca2fda868c1e8b2c2caf76af7dfcad3#gistcomment-3969223
- https://github.com/facebook/create-react-app/issues/10892
- https://github.com/nodejs/modules/issues/509
- https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1
- https://kentcdodds.com/blog/misunderstanding-es6-modules-upgrading-babel-tears-and-a-solution
- https://2ality.com/2014/09/es6-modules-final.html
- https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/
- https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c#gistcomment-3992076
- https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c#gistcomment-3850849
- https://nodejs.org/api/packages.html#packages_dual_package_hazard
- https://github.com/microsoft/TypeScript/issues/46452
- https://github.com/vercel/next.js/issues/17806

- https://esbuild.github.io/content-types/#default-interop

- https://sokra.github.io/interop-test/

  - https://twitter.com/wsokra/status/1329088911528714244

- https://github.com/standard-things/esm

- https://github.com/microsoft/TypeScript/issues/16577#issuecomment-703190339
- https://github.com/microsoft/TypeScript/issues/15479#issuecomment-543329547

## TODO:

- Use of `esm` to import ESM in CJS (provide an example)

## Things to cover

- Brief history / why bundling
- Dependency resolution / graph
- `import` = static (expose variable bindings) and async
- `require` = dynamic (function call, expose object `module.exports`) and sync
- `import`'s must live at the root level
- `import`'s also get hoisted, so can be written anywhere in the code (as long as they're at root level)
- `require` on the other hand is resolved at runtime, which means that it's only evaluated in the place in code where it's called (this is also why it can be called conditionally)
- `import` can take in only a string literal, whereas `require` accepts any JS expression
- CommonJS doesn't know what's going to be loaded ahead of time (since `require` is dynamic)
- With ESM you can statically analyze and tree-shake code

- With classic scripts (ie. `<script src="app.js" />`) everything is in the global context (`window` object)
- IIFE's were the first attempt to modularize JS code (vars declared within a function are scoped to that function)
- Tools exist to run CommonJS modules in browsers (ex. `browserify`), which make it behave the same way they do in Node

## Why is it difficult to move away from CommonJS?

- Node was built on it
- It's everywhere
- Lots of large codebases still using it

## Interoperability Concerns

Info accumulated from the following sources:

- [Rollup GitHub Issue #481](https://github.com/rollup/plugins/issues/481)
- [Rollup GitHub Issue #658](https://github.com/rollup/plugins/pull/658)
- [Babel GitHub Isse #12363](https://github.com/babel/babel/issues/12363)
- [Rollup Docs](https://rollupjs.org/guide/en/#outputinterop)

### ESM that was transpiled to CJS

> The problem here is to maintain isomorphic behaviour between the original ES module and the CJS module. Named exports are handled mostly correctly when using the "NodeJS with named imports" pattern (except we do not throw for missing exports) however the default export should not be `module.exports` but `module.exports.default`. This is incompatible with the previously listed interop patterns.
>
> At the moment most tools implement a runtime detection pattern for this by adding an `__esModule` property to `module.exports` to signify this is a transpiled ES module. Then the algorithm when getting the default import is
>
> - If this property is present, use `module.exports.default` as the default export
> - Otherwise use `module.exports`

**NOTE:** If the entry point doesn't contain any hint it's a compiled ES module, it gets imported as a normal CommonJS module, which doesn't have a default export.

### Using CJS in ESM

One of the biggest differences

## Module Scope

The way modules are loaded is different between browsers and server environment (ie. NodeJS).

Browser loads modules as "stateful singletons" - meaning that the same module will share its state anywhere it's imported in the application for that session.

> "When you import a module, you're not getting a piece of code that you're running, you get reference to an object in memory"

[source](https://youtu.be/j1s_3zytAcM?t=1740)

In a Node.js environment, however, modules are loaded as instances - and as such, each instance has its own state, not shared with any of the other instances of the same module.

## Talking Points

- [output.preserveModules](https://rollupjs.org/guide/en/#outputpreservemodules)
-

## Issue with MUX bundle

The root of the problem in issue [#2071](https://github.com/manulife-innersource/mux-core/issues/2071) was that `prop-types` was not included in the list of `peerDependencies` in `package.json`, even though it is used internally by the library (meaning that MUX needs that lib to be present in `node_modules` to work properly).

In our Rollup config, we specify a list of `external` modules by pulling the names from `dependencies` and `peerDependencies` in `package.json`, which tells Rollup to not transform any of those modules and not include them in our final bundle. But as I mentioned above, `prop-types` was not included in that list. So, Rollup assumed that the code for `prop-types` needed to be included in the bundle, and would run it through the list of plugins, which includes `@rollup/plugin-commonjs`. This plugin takes CommonJS code and transforms into ES Module format, so that it can be included in the bundle. Problem with this, however, is that we don't need this to happen. The `prop-types` library is already published in the correct format, so there is no need to do this within our bundle (and include it, additionally). By doing that, we are introducing a potential for errors to happen. Which is exactly what happened with this issue.

The particular of what exactly happened are the follows:

- the `prop-types` package wasn't marked as "external", thus being included in the bundle (and as such, having the transformations applied)
- we have `exports: "named"` option set in Rollup config, since all of MUX modules are named exports (by design)
- however, this didn't take into account the presence of `prop-types` in that list, which is a CommonJS module (since that's what it's published as)
- when `output.exports` is set to `"named"`, Rollup creates a CommonJS module where the exports are an object with the `default` property
